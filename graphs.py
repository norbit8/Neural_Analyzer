# IMPORTS
from typing import List
import pickle
import os
import numpy as np
import math
from pandas import DataFrame
from plotnine import *  # ggplot

CRED = '\033[91m'
CEND = '\033[0m'


class Graphs:
    """
    Graphs class.
    Responsible for drawing and getting all of the data generated by the decoder class.
    """

    def __init__(self, population_names: List[str], exp_names: List[str],
                 base_dir: str, number_of_cells: int = 1000,
                 fragments_cells: List[int] = [0, 9, 19, 29], load_fragments: bool = False):
        """
        Ctor of the graphs class
        :param population_names: All of the populations to load
        :param base_dir: The base dir, where all of the data is located.
        """
        # windows / linux checker
        if os.name == 'nt':  # windows
            self.__slash = '\\'
        elif os.name == 'posix':  # Linux , Mac OSX and all the other posix compatible os.
            self.__slash = '/'
        else:
            self.__slash = '\\'
        self.__populations = population_names
        self.__experiment_names = exp_names
        # Verifying that the last char of the base dir is '/' (I use it later)
        if base_dir[-1] != self.__slash:
            self.__base_dir = base_dir + self.__slash
        else:
            __base_dir = self.__base_dir = base_dir
        self.__df = None  # empty DataFrame
        self.__frag_df = None  # empty DataFrame for the fragments
        self.__number_of_cells = number_of_cells
        self.data_loader(number_of_cells)  # loading the regular data
        if load_fragments:
            self.data_loader_fragments(fragments_cells)  # loading the fragments data

    def creates_data(self, info: List, max_cells_number: int):
        """
        This method helps to create the list of the data
        :param info: list of data.
        :param number_of_cells: Number of cells to load to the DataFrame. (INCLUSIVE)
        :return: new sorted list.
        """
        success_rate = []
        number_of_cells = []
        data = []
        for i, k in enumerate(info[:max_cells_number + 1]):
            number_of_cells.append(i + 1)
            success_rate.append(k[1])
        data.append(number_of_cells)
        data.append(success_rate)
        return data

    def get_list_from_data(self, number_of_cells: int):
        """
        Loads the data from the disk into an array.
        :param number_of_cells: Number of cells to load to the DataFrame. (INCLUSIVE)
        :return: List representing the data loaded earlier using pickle.
        """
        exps_data = []
        for exp_index, exp_name in enumerate(self.__experiment_names):
            exps_data.append([])
            for population in self.__populations:
                with open(self.__base_dir +
                          str.upper(exp_name) + self.__slash +
                          str.upper(population),
                          'rb') as info_file:
                    info = pickle.load(info_file)
                    exps_data[exp_index].append(self.creates_data(info, number_of_cells))
        return exps_data

    def data_loader(self, number_of_cells: int):
        """
        Loading all of the data into pandas DataFrame.
        And saving the DataFrame into a private variable.
        :param number_of_cells: Number of cells to load to the DataFrame.
        :return: Nothing.
        """
        exps_data = self.get_list_from_data(number_of_cells)
        # DataFrame creation
        df = DataFrame(columns=['concatenated_cells', 'acc', 'population', 'experiment_type'])
        for exp_index, exp_type in enumerate(exps_data):
            for index, pop in enumerate(self.__populations):
                for readable_data in zip(exp_type[index][0], np.around(exp_type[index][1], 3)):
                    df = df.append({'concatenated_cells': readable_data[0],
                                    'acc': readable_data[1],
                                    'population': pop,
                                    'experiment_type': self.__experiment_names[exp_index]},
                                   ignore_index=True)
        # df.loc[(df['experiment_type'] == 'PURSUIT'), ['acc']] += 0.1
        self.__df = df

    def plot_acc_over_concat_cells(self, populations: List[str] = None,
                                   experiment_types: List[str] = None, number_of_concat_cells: int = 100,
                                   ticks: int = 1):
        """
        Drawing a graphs of accuracies over number of concatenated cells, of all the populations selected.
        and of all of the experiment types.
        :param populations: Selected populations.
        :param experiment_types: experiment types.
        :param number_of_concat_cells: Number of cells to show !!!INCLUSIVE!!!. (X Axis ticks)
        :return: The filtered DataFrame.
        """
        filtered_dataframe = self.data_acc_over_concat_cells(populations, experiment_types, number_of_concat_cells)
        if number_of_concat_cells > self.__number_of_cells:
            print(CRED + "You Don't have enough cells, so only " + str(self.__number_of_cells) + " was printed." + CEND)
        print(ggplot(data=filtered_dataframe,
                     mapping=aes(x='concatenated_cells', y='acc', color='population', group='population')) + \
              geom_line() +
              geom_point() +
              facet_wrap('~experiment_type') +
              scale_x_discrete(breaks=range(0, number_of_concat_cells + 1, ticks)) +  # X axis leaving out some ticks
              scale_y_continuous(breaks=np.arange(0, 1, 0.05)) +  # Y axis scaling
              labs(x='Number of concatenated cells', y='Accuracy') +
              theme_classic())
        return filtered_dataframe

    def plot_experiments_same_populations(self, populations: List[str] = None,
                                   experiment_types: List[str] = None, number_of_concat_cells: int = 100,
                                   ticks: int = 1):
        """
        Drawing a graphs of accuracies over number of concatenated cells, of all the populations selected.
        and of all of the experiment types.
        :param populations: Selected populations.
        :param experiment_types: experiment types.
        :param number_of_concat_cells: Number of cells to show !!!INCLUSIVE!!!. (X Axis ticks)
        :return: The filtered DataFrame.
        """
        if populations is None:
            populations = self.__populations
        if experiment_types is None:
            experiments = self.__experiment_names
        filtered_dataframe = self.data_acc_over_concat_cells(populations, experiment_types, number_of_concat_cells)
        if number_of_concat_cells > self.__number_of_cells:
            print(CRED + "You Don't have enough cells, so only " + str(self.__number_of_cells) + " was printed." + CEND)
        for pop in populations:
            print(ggplot(data=filtered_dataframe[(filtered_dataframe['population'] == pop)],
                         mapping=aes(x='concatenated_cells', y='acc', color='experiment_type', group='experiment_type')) + \
                  geom_line() +
                  geom_point() +
                  scale_x_discrete(breaks=range(0, number_of_concat_cells + 1, ticks)) +  # X axis leaving out some ticks
                  scale_y_continuous(breaks=np.arange(0, 1, 0.05)) +  # Y axis scaling
                  labs(x='Number of concatenated cells', y='Accuracy') +
                  theme_classic())
        return filtered_dataframe

    def data_acc_over_concat_cells(self, populations: List[str] = None,
                                   experiment_types: List[str] = None, number_of_concat_cells: int = None):
        """
        Gets the data frame of accuracies over number of concatenated cells, of all the populations selected.
        and of all of the experiment types.
        :param populations: Selected populations.
        :param experiment_types: experiment types.
        :param number_of_concat_cells: Number of cells to show !!!INCLUSIVE!!!. (X Axis ticks)
        :return: The filtered DataFrame.
        """
        if populations is None or experiment_types is None or number_of_concat_cells is None:
            return self.__df
        if number_of_concat_cells > self.__number_of_cells:
            print(CRED + "You Don't have enough cells, so only " + str(self.__number_of_cells) + " was printed." + CEND)
        return self.__df[(self.__df['population'].isin(populations)) &
                         (self.__df['experiment_type'].isin(experiment_types)) &
                         (self.__df['concatenated_cells'].isin(
                             [num for num in range(number_of_concat_cells + 1)]))]

    def creates_data_frag(self, info):
        success_rate = []
        number_of_cells = []
        CRB = []
        for i, k in enumerate(info):
            number_of_cells.append(i + 1)
            success_rate.append(k[1])
        CRB.append(number_of_cells)
        CRB.append(success_rate)
        return CRB

    def create_std_data_frag(self, info):
        """
        creates the std
        :param info:
        :return:
        """
        stds = []
        number_of_cells = []
        for i, k in enumerate(info):
            number_of_cells.append(i + 1)
            stds.append(
                np.std(np.array([score_for_cells[0][1] for score_for_cells in k[0]]), ddof=1) / math.sqrt(50))
        stds_per_files = (number_of_cells, stds)
        return stds_per_files

    def data_loader_fragments(self, fragments_cells: List[int]):
        """
        Creating the fragments list
        :param number_of_fragments: number of fragments.
        :return: list of the loaded data.
        """
        # REG
        all = []
        for index, exp in enumerate(self.__experiment_names):
            all.append([])
            for pop in self.__populations:
                temp = []
                for i in range(12):
                    with open(self.__base_dir + exp + '_FRAGMENTS' + self.__slash +
                              str.upper(pop) + '_' + str(i), 'rb') as info_file:
                        info = pickle.load(info_file)
                        temp.append(self.creates_data_frag(info))
                all[index].append(temp)
        # STD
        all2 = []
        for index, exp in enumerate(self.__experiment_names):
            all2.append([])
            for pop in self.__populations:
                temp2 = []
                for i in range(12):
                    with open(self.__base_dir + exp + '_FRAGMENTS' + self.__slash +
                              str.upper(pop) + '_' + str(i), 'rb') as info_file:
                        info = pickle.load(info_file)
                        temp2.append(self.create_std_data_frag(info))
                all2[index].append(temp2)
        # loading the df
        self.__frag_df = DataFrame(
            columns=['time', 'acc', 'population', 'concatenated_cells', 'experiment_type', 'std'])
        for time in range(12):  # Time
            for index, exp_type in enumerate(self.__experiment_names):  # Saccade vs pursuit
                for pop_index, population_type in enumerate(self.__populations):  # Population
                    # for cell_number in [0, 9, 19, 29]:  # Cell numbers
                    for cell_number in fragments_cells:  # Cell numbers
                        try:  # Only because of the Saccade ss problem
                            # (time * 100) + 1000
                            self.__frag_df = self.__frag_df.append({'time': time,
                                                                    'acc': all[index][pop_index][time][1][cell_number],
                                                                    'population': population_type,
                                                                    'concatenated_cells': cell_number + 1,
                                                                    'experiment_type': exp_type,
                                                                    'std': all2[index][pop_index][time][1][
                                                                        cell_number]}, ignore_index=True)
                        except:
                            print("ERROR: we don't have " + str(cell_number) + " cells in:",
                                  exp_type, population_type + '.', '(Time: ' + str(time) + ')')

    def get_fragments(self, populations: List[str] = None,
                       experiments: List[str] = None):
        """
        Getter for the fragments data
        :return: fragments data frame
        """
        if self.__frag_df is None:
            print(CRED + "Fragments are not loaded, please create a new graphs instance with the relevant flag" + CEND)
            return
        if populations is None:
            populations = self.__populations
        if experiments is None:
            experiments = self.__experiment_names
        return self.__frag_df[(self.__frag_df['population'].isin(populations)) &
                       (self.__frag_df['experiment_type'].isin(experiments))]

    def plot_fragments(self, populations: List[str] = None,
                       experiments: List[str] = None):
        """
        Printing the fragments graphs
        :return: None if there is an error, and the DataFrame representing the fragments data.
        """
        if self.__frag_df is None:
            print(CRED + "Fragments are not loaded, please create a new graphs instance with the relevant flag" + CEND)
            return
        if populations is None:
            populations = self.__populations
        if experiments is None:
            experiments = self.__experiment_names
        for exp_index, exp_type in enumerate(experiments):
            print("Printing " + exp_type)
            for population in populations:
                print(ggplot(data=self.__frag_df[(self.__frag_df['population'] == population) &
                                                 (self.__frag_df['experiment_type'] == exp_type)],
                             mapping=aes(x='time', y='acc', group=1)) +
                      geom_line(color='red') +
                      geom_point() + facet_wrap('~concatenated_cells') +
                      ggtitle(population + ' ' + exp_type) +
                      theme_classic() +
                      geom_errorbar(mapping=aes(x="time", ymin='acc-std', ymax='acc+std')))
        return self.__frag_df

    def help(self):
        print("commands: \n"
              " (*) plot_acc_over_concat_cells(populations: List[str] = None,"                           
              "experiment_types: List[str] = None, number_of_concat_cells: int = 100,"
              "ticks: int = 1"
              ") - Draws the graph of the concatenated cells over their accuracies.\n"
              " USAGE: \n"
              "populations - Provide a list of all of the desired populations. example: ['SNR', 'CRB', 'SS'] \n"
              "experiment_types - Provide a list of all the experiment types. example: ['PURSUIT', 'SACCADE']\n"
              "number_of_concat_cells - Number of concatenated cells to show. example: 30\n"
              "ticks - The jumps on the X axis. example: 1 \n\n"
              " (*) data_acc_over_concat_cells() - Getter for the data of the concatenated cells "
              "over their accuracies (Pandas DataFrame)\n"
              "USAGE: \n"
              "populations - Provide a list of all of the desired populations. example: ['SNR', 'CRB', 'SS'] \n"
              "experiment_types - Provide a list of all the experiment types. example: ['PURSUIT', 'SACCADE']\n"
              "number_of_concat_cells - Number of concatenated cells to show. example: 30\n\n"
              " (*) plot_fragments() - Plots the fragments.\n\n"
              " (*) get_fragments() - Getter for the fragments data. (Pandas DataFrame)")


## EXAMPLES ###
# g = Graphs(['SS', 'SNR', 'MSN', 'CRB'],
#            ['PURSUIT', 'SACCADE'],
#            '/home/mercydude/Desktop/Neural_Analyzer/out/',
#            number_of_cells=30, load_fragments=True)
#
# g.plot_experiments_same_populations()
